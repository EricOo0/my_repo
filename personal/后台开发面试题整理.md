
自己整理的c++后端面试资料，时间仓促，可能会有很多错误

[计算机网络](#计算机网络)  
[操作系统](#操作系统)  
[Linux](#Linux)   
[C++&&数据结构](#C数据结构)   
[SQL&&redis](#SQLRedis)   

#计算机网络
============
## ICMP部分：
  ICMP 网络控制消息协议，用于在IP协议中发送控制消息，运行在IP层，用于测试网络状况等     
  ping和tracroute发送的式ICMP报文    
  ICMP报文负责差错控制--负责错误报告，不负责错误纠正（IP报文只负责消息传输，不管差错控制）    
  常见错误：终点不可达，超时，源点抑制   
## DNS    
  DNS是域名系统（Domain Name System），是将域名和IP地址的之间进行转换的一项服务gethostbyname     
  域名转换时会先区浏览器缓存查询域名对应的IP，如果没有，会去本地HOSTS里查询，如果没有才会到DNS服务 器上去寻找。      
  DNS运行在应用层，域名解析是基于UDP的（块，简单）       
## ARP
  ARP地址解析协议，提供IP地址和MAC地址的转换服务；属于网络层    
  ARP地址请求是广播，向所有用户请求目的IP的mac地址；arp回复是单播。    
  linux下用 arp -a 查看arp缓存；一个地址在arp缓存中有老化时间，过期会被删除。    
  arp攻击：arp是一种不安全的协议--arp洪泛 arp欺骗    
## TCP/IP和UDP部分    
* TCP和UDP区别：  
  Tcp面向连接，需要三次握手四次挥手，是可靠传输。 而udp不面向连接是不可靠传输（尽最大努力传输）  
  TCP是字节流而UDP是报文  
  TCP有拥塞避免（作用于网络）-慢开始，快恢复，快重传，流量控制（作用于接收放，接收窗口），UDP无     
  TCP适用于文件传输等对可靠性要求高的（邮件，文件传输），UDP适用于实时应用（语言，视频）    
  TCP首部20字节，UDP首部8字节       
  TCP慢，资源消耗多，udp快，资源消耗少    
* 拥塞避免算法：   
发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。  
慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小   
当拥塞窗口大于拥塞门限，采用拥塞避免算法，线性增加+1   
当发生超时情况--没有收到确认就认为是网络拥塞，慢开始门限设为当前拥塞窗口一半，拥塞窗口设为1   
快重传：发送方收到连续三个同一个确认报文，就直接重传，不等超时   
快恢复：发送方收到连续三个同一个确认报文，把慢开始门限设为一般，执行拥塞避免算法   
TCP报文结构：   
头部包含：源目的端口号，序号与确认序号，校验和，报文长度，数据偏移（UDP可能在IP层分片）等   
* 分包和粘包：  
当发送间隔很短，包长度很小时，socket内部会把几个报文打包成一个发送   
当报文太大的时候，socket内部会拆分成几个报文发送   
解决办法：加头部，标明数据长度，或加起止标志   
* 四次挥手的状态分别是：   
请求关闭报文fin ,客户端进入fin_wait1,服务器接收并回复fin_ack,服务器进入close_wait   
客户端接收ack，进入fin_wait2;    
服务器发出关闭请求，进入last_ack,客户端接收并回复确认，进入time_wait状态   
四次挥手是因为全双工，为了双方断开   
* 三次握手的状态：   
Syn_send -> syn_recv -> established -> established   
为什么要三次握手，因为tcp是全双工的，需要测速双方的收发能力都是正常的。   
* 可以两次握手吗?  
  不可以，如果只进行两次握手：1、当服务器的确认丢失的时候，服务器以为成功建立了连接，但客户端却认为没有建立。此时服务器向客户端发送数据会被丢弃          
  2、客户端发出连接请求超时后到达服务器，服务器仍接收请求发出确认，但客户端此时不需要建立连接，浪费资源    
 * 为什么要有time_wait 阶段    
  1、客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。    
  2、考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。    
 * 如果已经建立了连接，但是客户端突然出现故障了怎么办？      
    如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。
初始化双发的序列号；为什么要随机初始化，防止被攻击      

![image1 tcp](https://github.com/EricOo0/my_repo/blob/master/Image/tcp.jpg)    
* UDP最大报文长度：     
1480（因为以太网帧长度为1500，ip首部20字节）     
## HTTP 部分    
* http和https区别？    
  端口：http-80  https-443    
  安全性：https有加密机制更安全    
  协议：http运行在tcp之上，https运行在ssl层上（安全套接字层）而ssl运行在tcp层上。    
* https过程:      
HTTPS实际上就是HTTP穿上了SSL/TLS的外套; 增加一层SSL（安全套接字）    
密钥磋商过程：     
客户端发起一个http请求，连接端口443     
服务器把自己的数字证书，公钥等信息发给客户端（非对称密钥）     
客户端验证证书合法性，生成对称密钥，用公钥加密后发给服务器     
* HTTP请求过程：     
域名解析（DNS）获得IP -> 对服务器发起TCP连接（3次握手）-> 连接成功后可以发送http请求（post，get）->服务器响应，发送页面->浏览器解析渲染      
* 状态码：    
2xx：成功响应 3xx:重定向状态码 4xx：客户端错误 5xx:服务器错误      
* http格式：     
请求行（request line-请求方法+url+协议版本）、请求头部（header）、空行和请求数据4个部分       
* HTTP长连接短链接：       
Http 1.0：短链接 耗费太多资源，每次发送都有链接      
Http 1.1：长连接+心跳机制       
长链接+连接池--防止高并发占用太多资源     
* http端口号    
http端口是80 https是443    
* HTTP的无连接和无状态    
HTTP协议是应用层协议，主要五大特点：支持客户-服务器模式，简单快速，灵活，无连接，无状态    
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，服务器无法判断用户身份。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。--（用cookie和session解决）    
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。        
* session和cookie    
  Cookie    
Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。    
Session    
Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。     
Token      
客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。看到这里很多人感觉这不是和sessionid作用一样吗？其实是不一样的，但是本文章主要针对面试，知识点很多，篇幅有限，几句话也解释不清楚，大家可以看看这篇文章，我觉得说的非常清楚了。
    
## 其他
* 什么是nginx：    
Nginx是一款轻量级的Web服务器、也可以用来做反向代理服务，具有简单的负载均衡；   
支持高并发（epoll，多进程，多路复用和事件通知）-异步非阻塞，响应更快-可以缓存静态文件（作为缓存服务器）   
启动Nginx后，其实就是在80端口启动了Socket服务进行监听   
分为master进程和worker进程（多进程单线程-） 
* Ospf,rip,stp的理解：   
* DHCP协议：   
动态获取IP；四个过程：发现过程（寻找dhcp服务器地址）提供阶段（服务区提供IP）选择阶段（客户端选择第一个提供的IP）确认阶段（服务器确认）    

#操作系统   
===========      
* 内核态和用户态?
内核态（ring0）与用户态(ring3)是操作系统的两种运行级别.操作系统通过系统调用将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间），程序一开始都是运行于用户态，当程序需要使用系统资源、访问硬件时，就必须通过调用软中断（80号）进入内核态,使用cpu指令操作硬件。在这种保护模式下，即时程序发生崩溃也是可以恢复的.    
* 陷阱、中断、异常、信号    
陷阱:是有意造成的“异常”，是执行一条指令的结果。又叫”软中断“，基本上是一条指令，告诉内核从用户模式切换到内核模式。示例:在系统调用期间，TRAP指令将强制内核代表进程在内核(内核模式)内执行系统调用代码。    
信号:信号由内核生成，并在发生异常时发送到进程。例如，除以零指令将导致内核为该过程生成SIGSEGV信号(段错误)。    
异常:这些是由处理器生成的中断（异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。）。示例:除以零。这些本质上是同步的，这意味着处理器知道中断的产生       
中断：由硬件生成。示例:由键盘生成的中断，用于在屏幕上键入字符。    

* 进程和线程的区别？    
1、进程是运行着的程序，是资源分配的基本单位；进程有三种状态：运行态，就绪态，阻塞态；进程有自己的地址空间，不同进程之间相互独立，隔离。不同进程之间通过IPC通信（进程间通信）。    
2、线程是CPU管理和调度的基本单位，一个进程可以有多个线程。线程之间共享资源，（有自己的独立栈空间），通过加锁同步。      
    线程可以分为：    
    	1、用户级线程-不需要进入内核（内核不知道线程的存在），效率高     
	2、内核级线程-由内核进行管理，调度

* 进程间通信的方式：   
管道   
命名管道   
消息队列  
共享内存   
信号量   
Socket 

* 不同的线程的什么内存空间共享，什么内存空间不共享？  
线程创建时共享进程的代码端和堆，数据段；线程有自己独立的栈空间   

* 线程同步的方式有哪些？   
互斥锁 一个时间只能有一个访问  	 
信号量 一个时间可以有若干个访问   
自旋锁  
读写锁  

* 线程同步：   
互斥量：当有线程占用资源，当前线程会阻塞（休眠，放弃cpu）--上下文切换开销大   
读写锁：只有一个写锁，可以有多个读锁    
条件变量     
自旋锁：资源被占用的时候处于忙等待的状态（自旋占用cpu）   
屏障：屏障允许每个线程等待，直到所有的合作线程都达到某一点     

* 进程切换的上下文
当CPU需要切换到另一个进程时（阻塞或者时间片到了等情况），需要保持当前进程的所有状态（即保留上下文），进程的PCB程序控制块保存了当前程序的运行状态（堆 栈 指针等）
内核态中不区分进程和线程，线程是轻量级进程，都使用task_struct结构保存；线程切换比进程切换更快，损耗更小    
* 静态库和动态库有什么区别？    
库是共享程序代码的方式，一般分为静态库和动态库。    
静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。.a为后缀      
动态库：链接时不复制,只将符号复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。.so为后缀；可用ldd查看        
动态连接-占用内存小，方便更新   静态连接：快，不需要依赖其他文件
* 用户态和内核态区别？
 内核态运行操作系统程序，操作硬件
 用户态则运行用户程序，用户程序要想执行特权指令或操作硬件，需要通过系统调用陷入内核态，从内核态调用
 陷入内核态的方式：系统调用，中断，异常

* 写时复制 Copy-on-write  
    父进程fork子进程的时候，会复制父进程的所有资源，包括打开的描述符和文件等（以只读的方式），即两个进程映射的是同一段物理空间，当子进程要写这段空间时或执行exec会进行重新映射。    
    https://juejin.cn/post/6844903702373859335    
    
* Epoll，poll，select区别：
IO多路复用  
Epoll是事件触发机制，没有描述符限制；三个主要函数：epoll_create(int size)；poll_ctl(int epfd， int op， int fd， struct epoll_event *event)； int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout);    
 
核心结构是红黑树和链表-监听的描述符添加到红黑树，epoll_ctr进行管理；触发的描述符通过链表管理
水平触发：只要缓存区不空，就触发可读
边沿触发：只要有新数据到达就触发可读 通过设置events的EPOLLET设置
但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
EPOLL默认是水平触发，设置成编译触发时要设置成非阻塞IO，因为ET模式下每次读写要循环read、write直到返回EAGAIN错误，如果使用阻塞IO，则会阻塞在最后一次读写，而不是返回错误。

Select和poll是轮询，select用数组，最多1024个描述符，poll是链表，无限制
Epoll有两种触发方式：水平触发：当缓冲区有东西都会触发；边沿触发：当又新的内容进入缓冲区才触发
    
## IO模型    
     阻塞IO(BLOCKING):阻塞在当前位置等待响应    
     非阻塞IO（non-blcking）:指向时如果kernel未准备好回立刻返回一个错误（用户进程会不断询问）    
     多路复用IO：select，epoll,不需要用户程序不断询问    
     异步IO：用户发起操作（read）后立刻返回，不对进程产生阻塞。kernel等数据准备好后会把数据拷贝到用户内存，然后给用户进程发送一个signal，报告操作完成；和非阻塞IO的区别：在数据准备好后，非阻塞IO实际上时需要阻塞程序将数据从内核拷贝到用户内存的，而异步IO不需要，内核非阻塞地完成这项任务    
     信号驱动IO:调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。    
* Grep,awk,sed-linux三剑客：sed是一个流编辑器   
* ulimit -c unlimited:开启core  
 
#Linux    
============  
* Linux由内核，shell，文件系统和应用程序组成   
* 0号进程和1号进程：   
0号进程运行在内核态，系统运行的第一个进程（非fork），没有其他进程运行时才执行   
1号进程是其他所有进程的父进程   
* BIOS和bootloader：   
BIOS是固化的到ROM的程序，用来检测和初始化硬件；加载bootloder（ram），初始化硬件，加载内核；创建0号进程来创建环境，0号进程创建1号进程后转化位idle进程。   
*  同步异步，阻塞非阻塞：   
同步异步主要针对C端： 同步 – 在c端发出一个功能调用时，没有得到结果就不返回。  主要从消息通知的角度区分 ，异步是通过回调通知调用者   
阻塞非阻塞主要针对S端，主要从等待消息通知的角度区分	   
* 如何统计出一台 Web Server 上的各个状态（ESTABLISHED / SYN_SENT / SYN_RECV 等）的个数？   
netstat -antl|grep ESTABLISTHED|wc -l    
* /proc文件夹    
    Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。
    用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。
    /proc下的一些文件，如：/proc/cmdline 启动时传递给kernel的参数信息;/proc/cpuinfo cpu的信息;/proc/filesystems 内核当前支持的文件系统类型;/proc/modules 所有加载到内核的模块列表
    有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的 PID号为目录名，
    
* 常用命令：   
 Linux中查看cpu和内存的占用率怎么看？   top命令   
看磁盘空间 df     
看文件大小du   
Linux 查看端口占用情况可以使用 lsof 和 netstat 命令：
  lsof(list open files)是一个列出当前系统打开文件的工具。lsof -i:8000查看8000端口的占用情况;


#C++&&数据结构 
=============  
* 静态多态和动态多态：   
一种接口，多种方法。
静态多态：编译期间完成的多态—函数重载与隐藏，函数模板   
动态多态：运行时完成的多态—虚函数

* 重载和覆盖和隐藏：  
重载：函数名相同，参数不同；要求在一个类中   
子类覆盖父类的函数，同名同参；必须是virtual   
隐藏：如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆，重载要求在一个类中）。   
如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字（虚函数）。此时，基类的函数被隐藏（注意别与覆盖混淆，如果基类中有virtual关键字，而为覆盖）   

* 构造函数一般不是虚函数：   
创建类的时候还没有虚函数表，如果是虚函数无法调用构造函数   
析构函数一般是虚函数，当基类指针指向子类对象的时候可以释放子类对象的空间（默认不是虚函数因为默认时不会被继承的类）； （父类指针不能访问子类的新函数）  
* 纯虚函数，虚函数：  
父类中没有实现的虚函数是纯虚函数，必须被继承和重写   
* 哪些函数不可以被继承：   
构造函数，析构函数，运算符重载 
子类继承父类时，会有一个默认的自己的构造函数   
* 指针和引用的区别:	 
引用只是一个别名，需要先初始化变量，没有分配空间；指针有自己的地址空间；引用不能被改变，好处是传参的适合时候不需要重新开辟空间进行初始化。       
    
* 三种继承方式：
 默认是private继承
 public：is a 继承；公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。    
 private：has a;私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。而基类的私有成员仍然是私有的。     
 protected：has a;保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。     

* New和malloc区别：  
new/delete是C++关键字，需要编译器支持。 
malloc/free是库函数，需要头文件支持   
new不用计算分配大小，malloc需要指定分配大小   
new返回的是对象类型的指针，malloc返回的是void指针   
new失败抛出异常，malloc失败返回null   
* 对象的什么函数不能被声明为虚函数  
（构造函数，内联函数inline，静态函数）    
* C++内存布局   
代码段 全局、静态区 常量区 堆 栈   
* 指针占几个字节：   
和系统有关，32位机固定占4字节   
* Static关键字：   
变量存储位置是栈，静态变量存储位置是静态区（全局区），没有初始化的话自动初始化成0   
全局静态变量：作用域为本文件，其他文件不可见   
局部静态变量：作用域仍为局部，但是离开作用域不会销毁，下次进入不会再次初始化   
静态函数：本文件可见，其他文件不可见；static函数不能再头文件声明， static作用域会本文件，每次include这个头文件都会定义一遍这个变量，导致有多份同名变量。  
静态成员和静态成员函数：属于类，不属于对象；   
* Extern 关键字   
被extern"C"修饰的变量和函数是按照C语言方式编译和连接的   
* 函数指针： 
int (*p)(int, int)    
数组名和指针不一样：  
Sizeof(数组名)是数组长度   
Size(指针)是4/8   
数组名本身代表的就是数组的起始地址，指针有自己的地址指向数组   
* Sizeof 和 strlen：    
算数组长度时sizeof会多1，他计算\0结束符。strlen不算   
预处理 -> 编译 -> 汇编 -> 链接       

* 四种cast转换：  
xxx_cast<newtype> (data)   
Static_cast：用于各种隐式转换   
dynamic_cast:动态转换，用于各种类的向上向下转换   
const_cast：将const转换成非const   
reinterpret_cast：什么都能转但是有风险   
  
* 四种智能指针：自动析构指针，防止内存泄漏   
Shared_ptr循环引用会导致内存泄漏   
Auto_ptr：c++11弃用；类似unique指针，转移时会出问题，转移所有权时会将原指针置空？   
Shared_ptr:：共享指针，引用计数   
Weak_ptr: 防止share_ptr死循环不释放资源；不增加引用计数    
Unique_ptr:独占指针   
std:move的作用是用来转移所有权，被转移的对象会被置空？

* 虚函数表存放位置   
全局区   
* 拷贝构造可以用值传递吗？   
不可以；如果使用值传递，则还需要调用拷贝构造将形参赋给实参，会无限循环   
* Set和map 
都是关联容器，map时key-value，set时key；都不允许修改key，但可以删除，map支持下标索引，底层都是红黑树 
* 编译错误和运行错误：  
编译错误--编译器可以检测出来，比如语法错误，符号错误等   
运行错误--代码的逻辑错误，得靠程序员自己检查，编译不会报错，比如内存越界溢出等   
* 哈希表：
通过散列函数将键值映射到数组某一位置  
碰撞：拉链法-通过链表存储多个value  
重哈希     
* Map的insert和[]的区别 ？     
 []是操作符重载，如果搜索的key不存在，会创建一个value为默认值的插入到红黑树中。
 当插入新key-value时，insert效率更高
 当key-value存在时，insert不能成功插入，[]可以更新value
 * 红黑树和AVL树
 红黑树和AVL树都是自平衡的二叉搜索树；
 AVL树是严格的平衡二叉树，左右子树的最大高度差不超过1，当插入失衡时需要进行旋转
 红黑树不追求严格的平衡，但是在插入和删除的时候代价比AVL树小  
 AVL查找效率更高，红黑树插入和删除效率更高；实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。      
 
# STL部分
  推荐侯捷老师的C++系列视频
* STL 六大组件
  容器container：帮助我们管理内存,存储数据的结构       
  分配器allocator：用来支持容器，帮助容器分配内存    
  算法algorithm：操作容器    
  迭代器iterator：泛化的指针，连接容器和算法    
  适配器adaptor    
  仿函数functor    
  ![image relationship](https://github.com/EricOo0/my_repo/blob/master/Image/components.png)    
* 容器：
  序列式容器：
    Array:固定长度，不可增长；array.data()可返回数组的第一个元素的地址        
    Vector：可动态增长（由分配器复制），每当空间不足时，会重新申请一个两倍的空间，将原来空间的数据复制过去    
            .size()返回元素的数量；.capacity()返回可容纳元素的大小>=size()；    
    Deque：双向队列，可向两侧动态扩充；在内存空间中时分段连续的     
           stack，queue时基于deque实现的，这二者是deque的适配器，它们不提供迭代器    
    List：双向链表，容器内有一个自己类的sort函数     
    forward_List：单向链表
  关联式容器(适合用于查找，key-value）：    
      set：底层都是红黑树（高度平衡）;不分keyvalue;
				有自己的find
			map：底层都是红黑树;（key-value）
			multiset、multiset：key可以重复    
	
	不定序容器：
			unordered_map:底层是vector+链表    
![image structure](https://github.com/EricOo0/my_repo/blob/master/Image/structure.png)    
![image structure2](https://github.com/EricOo0/my_repo/blob/master/Image/unorder_.png)
    
        
#SQL&&Redis     
===========  
* 四大特性：   
ACID:原子性atomic，一致性consistency，隔离性：isolation，持久性duration   
* 三大范式:   
第一范式：字段不可再拆分成子字段   
第二范式：各字段都和主键有联系     
第三范式：各字段只和主键有全部联系（只依赖于主键）   
* 五大约束：   
唯一约束：unique    
主键约束 primary    
外键约束:foreign     
默认约束：default   
非空约束：notnull  
* 索引类型    
1.普通索引    
2.唯一索引 ：索引列的值必须唯一 ，允许空  
3.主键索引 ：一个表只能有一个主键，不允许有空值   
4.组合索引    
5.全文索引   
* Mysql主要包含四种隔离状态   
读未提交Read Uncommitted：脏读-在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。   
读取提交内容Read committed：一个事务只能看见已经提交事务所做的改变   
可重复读 ：幻读，提交前读取的数据不变   
串行化   
* 数据库索引：加快检索表中数据的方法 
* Mysql索引：   
索引可以提高检索速度但会降低更新速度，需要更新索引文件   
* 数据库事务隔离：
同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。   
* 权限设置：   
通过用户名密码登录到账户   
Grand 权限（update，drop等）on 表 to 用户   
Revoke 撤销权限   
* 存储引擎：使用不同的技术将数据存储在文件或内存中(不同的表结构)；show engine看存储引擎    
Myisam：不支持事务，（基于hash）但是插入数据快，适合在插入或选择密集（读或写的多单一业务）数据库，对硬件要求低，表锁：不会发生锁冲突    
Innodb：支持事务，支持事务提交和回滚，加入外键约束，适合多重并发（更新密集）的数据库，行锁：容易死锁   
Memory：运行在内存上，速度快但容易丢失，不支持事务    

![image text](https://github.com/EricOo0/my_repo/blob/88853547c0b5a73f8ecd1492103a8e32f2dbd88c/Image/innodb.jpg)    

* Mysql主从一致：   
从库复制主库的binlog日志，执行日志命令来复制（两个线程）   
* Mysql回滚   
使用begin开始一个事务，在commit之前可以回滚rollback   
* 连接池：
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个   
一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。   
数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)   
1\程序初始化时创建连接池  
2\使用时向连接池申请可用连接   
3\使用完毕，将连接返还给连接池   
4\程序退出时，断开连接，并释放资源 
* Sql搜索可以考虑的数据结构 
哈希表：搜索快但是不适合范围查找   
二叉树：容易不平衡   
AVL：旋转耗时且IO消耗较大，如果深的话   
B树：有序数组+平衡多叉树；    
每个子节点可以存放多个值，树深度降低，适合查找   
B+树：有序数组链表+平衡多叉树   
每个子节点不存放值，只存放索引（地址），在叶子节点存放所有的数据，且用链表链接所有叶子节点（更适合范围查找，减少磁盘IO次数），每次查询需要的次数是一样的 
* 存储过程：  
预先通过编译和存储在数据库的一段sql命令集合   
* redis:  
非关系型数据库，是结构型数据存储   
* 内存管理机制上：
Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU（最少使用） 算法删除数据   
