
自己整理的c++后端面试资料，时间仓促，可能会有很多错误

[计算机网络](#计算机网络)  
[操作系统](#操作系统)  
[Linux](#Linux)   
[C++&&数据结构](#C数据结构)   
[SQL&&redis](#SQLredis)   

#计算机网络
============
* TCP和UDP区别：  
  Tcp面向连接，可靠传输 而udp不面向连接是不可靠传输  
  TCP是字节流而UDP是报文  
  TCP有拥塞避免（作用于网络）-慢开始，快恢复，快重传，流量控制（作用于接收放，接收窗口），UDP无   
  TCP适用于文件传输等对可靠性要求高的，UDP适用于实时应用   
* 拥塞避免算法：   
发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。  
慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小   
当拥塞窗口大于拥塞门限，采用拥塞避免算法，线性增加+1   
当发生超时情况--没有收到确认就认为是网络拥塞，慢开始门限设为当前拥塞窗口一半，拥塞窗口设为1   
快重传：发送方收到连续三个同一个确认报文，就直接重传，不等超时   
快恢复：发送方收到连续三个同一个确认报文，把慢开始门限设为一般，执行拥塞避免算法   
TCP报文结构：   
头部包含：源目的端口号，序号于确认序号，校验和，报文长度等   
* 分包和粘包：  
当发送间隔很短，包长度很小时，socket内部会把几个报文打包成一个发送   
当报文太大的时候，socket内部会拆分成几个报文发送   
解决办法：加头部，标明数据长度，或加起止标志   
* 四次挥手的状态分别是：   
请求关闭报文fin ,客户端进入fin_wait1,服务器接收并回复fin_ack,服务器进入close_wait   
客户端接收ack，进入fin_wait2;    
服务器发出关闭请求，进入last_ack,客户端接收并回复确认，进入time_wait状态   
四次挥手是因为全双工，为了双方断开   
* 三次握手的状态：   
Syn_send -> syn_recv -> established -> established   
为什么要三次握手，因为tcp是全双工的，需要测速双方的收发能力都是正常的。   
初始化双发的序列号；为什么要随机初始化，防止被攻击   
* UDP最大报文长度：  
1480（因为以太网帧长度为1500，ip首部20字节）   
* https过程:   
HTTPS实际上就是HTTP穿上了SSL/TLS的外套; 增加一层SSL（安全套接字）  
密钥磋商过程：   
客户端发起一个http请求，连接端口443   
服务器把自己的数字证书，公钥等信息发给客户端（非对称密钥）   
客户端验证证书合法性，生成对称密钥，用公钥加密后发给服务器   
* HTTP请求过程：   
域名解析（DNS）获得IP -> 对服务器发起TCP连接（3次握手）-> 连接成功后可以发送http请求（post，get）->服务器响应，发送页面->浏览器解析渲染   
* 状态码：   
2xx：成功响应 3xx:重定向状态码 4xx：客户端错误 5xx:服务器错误   
* http格式：   
请求行（request line-请求方法+url+协议版本）、请求头部（header）、空行和请求数据4个部分   
* HTTP长连接短链接：   
Http 1.0：短链接 耗费太多资源，每次发送都有链接   
Http 1.1：长连接+心跳机制   
长链接+连接池--防止高并发占用太多资源   
* 什么是nginx：    
Nginx是一款轻量级的Web服务器、也可以用来做反向代理服务，具有简单的负载均衡；   
支持高并发（epoll，多进程，多路复用和事件通知）-异步非阻塞，响应更快-可以缓存静态文件（作为缓存服务器）   
启动Nginx后，其实就是在80端口启动了Socket服务进行监听   
分为master进程和worker进程（多进程单线程-） 
* Ospf,rip,stp的理解：   
* DHCP协议：   
动态获取IP；四个过程：发现过程（寻找dhcp服务器地址）提供阶段（服务区提供IP）选择阶段（客户端选择第一个提供的IP）确认阶段（服务器确认）   

#操作系统   
===========  
* 不同的线程的什么内存空间共享，什么内存空间不共享？  
线程创建时共享进程的代码端和堆，数据段；线程有自己独立的栈空间   
* 线程同步的方式有哪些？   
互斥锁 一个时间只能有一个访问  	 
信号量	一个时间可以有若干个访问   
自旋锁  
读写锁  
* 线程同步：   
互斥量：当有线程占用资源，当前线程会阻塞（休眠，放弃cpu）--上下文切换开销大   
读写锁：只有一个写锁，可以有多个读锁    
条件变量     
自旋锁：资源被占用的时候处于忙等待的状态（自旋占用cpu）   
屏障：屏障允许每个线程等待，直到所有的合作线程都达到某一点   
* 进程间通信的方式：   
管道   
匿名管道   
消息队列  
共享内存   
信号量   
Socket   
* Epoll，poll，select区别：  
Epoll是事件触发机制，没有描述符限制   
Select和poll是轮询，select用数组，最多1024个描述符，poll是链表，无限制   
* Grep,awk,sed-linux三剑客：sed是一个流编辑器   
* ulimit -c unlimited:开启core  
 
#Linux    
============  
* Linux由内核，shell，文件系统和应用程序组成   
* 0号进程和1号进程：   
0号进程运行在内核态，系统运行的第一个进程（非fork），没有其他进程运行时才执行   
1号进程是其他所有进程的父进程   
* BIOS和bootloader：   
BIOS是固化的到ROM的程序，用来检测和初始化硬件；加载bootloder（ram），初始化硬件，加载内核；创建0号进程来创建环境，0号进程创建1号进程后转化位idle进程。   
*  同步异步，阻塞非阻塞：   
同步异步主要针对C端： 同步 – 在c端发出一个功能调用时，没有得到结果就不返回。  主要从消息通知的角度区分 ，异步是通过回调通知调用者   
阻塞非阻塞主要针对S端，主要从等待消息通知的角度区分	   
* 如何统计出一台 Web Server 上的各个状态（ESTABLISHED / SYN_SENT / SYN_RECV 等）的个数？   
netstat -antl|grep ESTABLISTHED|wc -l   
* 常用命令：   
 Linux中查看cpu和内存的占用率怎么看？   top命令   
看磁盘空间 df     
看文件大小du   

#C++&&数据结构 
=============  
* 构造函数一般不是虚函数：   
创建类的时候还没有虚函数表，如果是虚函数无法调用构造函数   
析构函数一般是虚函数，当基类指针指向子类对象的时候可以释放子类对象的空间（默认不是虚函数因为默认时不会被继承的类）；   
* 纯虚函数，虚函数：  
父类中没有实现的虚函数是纯虚函数，必须被继承和重写   
* 哪些函数不可以被继承：   
构造函数，析构函数，运算符重载 
子类继承父类时，会有一个默认的自己的构造函数   
* New和malloc区别：  
new/delete是C++关键字，需要编译器支持。 
malloc/free是库函数，需要头文件支持   
new不用计算分配大小，malloc需要指定分配大小   
new返回的是对象类型的指针，malloc返回的是void指针   
new失败抛出异常，malloc失败返回null   
* 对象的什么函数不能被声明为虚函数  
（构造函数，内联函数inline，静态函数）    
* C++内存布局   
代码段 全局、静态区 常量区 堆 栈   
* 指针占几个字节：   
和系统有关，32位机固定占4字节   
* Static关键字：   
变量存储位置是栈，静态变量存储位置是静态区（全局区），没有初始化的话自动初始化成0   
全局静态变量：作用域为本文件，其他文件不可见   
局部静态变量：作用域仍为局部，但是离开作用域不会销毁，下次进入不会再次初始化   
静态函数：本文件可见，其他文件不可见；static函数不能再头文件声明   
静态成员和静态成员函数：属于类，不属于对象；   
* Extern 关键字   
被extern"C"修饰的变量和函数是按照C语言方式编译和连接的   
* 函数指针： 
int (*p)(int, int)    
数组名和指针不一样：  
Sizeof(数组名)是数组长度   
Size(指针)是4/8   
数组名本身代表的就是数组的起始地址，指针有自己的地址指向数组   
* Sizeof 和 strlen：    
算数组长度时sizeof会多1，他计算\0结束符。strlen不算   
预处理 -> 编译 -> 汇编 -> 链接   
* 四种cast转换：  
xxx_cast<newtype> (data)   
Static_cast：用于各种隐式转换   
dynamic_cast:动态转换，用于各种类的向上向下转换   
const_cast：将const转换成非const   
reinterpret_cast：什么都能转但是有风险   
* 四种智能指针：自动析构指针，防止内存泄漏   
Shared_ptr循环引用会导致内存泄漏   
Auto_ptr：c++11弃用；类似unique指针，转移时会出问题   
Shared_ptr:：共享指针，引用计数   
Weak_ptr: 防止share_ptr死循环不释放资源；不增加引用计数    
Unique_ptr:独占指针   
* 指针和引用的区别:	 
引用只是一个别名，指针有自己的地址空间；引用需要先初始化变量；引用不能被改变，好处是传参的适合时候不需要重新开辟空间进行初始化。   
* 静态多态和动态多态：   
静态多态：编译期间完成的多态—函数重载，函数模板   
动态多态：运行时完成的多态—虚函数   
* 重载和覆盖和隐藏：  
重载：函数名相同，参数不同；要求在一个类中   
子类覆盖父类的函数，同名同参；必须是virtual   
隐藏：如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆，重载要求在一个类中）。   
如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字（虚函数）。此时，基类的函数被隐藏（注意别与覆盖混淆，如果基类中有virtual关键字，而为覆盖）   
* 虚函数表存放位置   
全局区   
* 拷贝构造可以用值传递吗？   
不可以；如果使用值传递，则还需要调用拷贝构造将形参赋给实参，会无限循环   
* Set和map 
都是关联容器，map时key-value，set时key；都不允许修改key，但可以删除，map支持下标索引，底层都是红黑树 
* 编译错误和运行错误：  
编译错误--编译器可以检测出来，比如语法错误，符号错误等   
运行错误--代码的逻辑错误，得靠程序员自己检查，编译不会报错，比如内存越界溢出等   
* 哈希表：
通过散列函数将键值映射到数组某一位置  
碰撞：拉链法-通过链表存储多个value  
重哈希 
   
#SQL&&redis     
===========  
* 四大特性：   
ACID:原子性atomic，一致性consistency，隔离性：isolation，持久性duration   
* 三大范式:   
第一范式：字段不可再拆分成子字段   
第二范式：各字段都和主键有联系     
第三范式：各字段只和主键有全部联系（只依赖于主键）   
* 五大约束：   
唯一约束：unique    
主键约束 primary    
外键约束:foreign     
默认约束：default   
非空约束：notnull  
* Mysql主要包含四种隔离状态   
读未提交Read Uncommitted：脏读-在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。   
读取提交内容Read committed：一个事务只能看见已经提交事务所做的改变   
可重复读 ：幻读，提交前读取的数据不变   
串行化   
* 数据库索引：加快检索表中数据的方法 
* Mysql索引：   
索引可以提高检索速度但会降低更新速度，需要更新索引文件   
* 数据库事务隔离：
同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。   
* 权限设置：   
通过用户名密码登录到账户   
Grand 权限（update，drop等）on 表 to 用户   
Revoke 撤销权限   
* 存储引擎：使用不同的技术将数据存储在文件或内存中(不同的表结构)；show engine看存储引擎    
Myisam：不支持事务，（基于hash）但是插入数据快，适合在插入或选择密集（读或写的多单一业务）数据库，对硬件要求低，表锁：不会发生锁冲突    
Innodb：支持事务，支持事务提交和回滚，加入外键约束，适合多重并发（更新密集）的数据库，行锁：容易死锁   
Memory：运行在内存上，速度快但容易丢失，不支持事务   
[image](https://github.com/EricOo0/my_repo/edit/master/Image/innodb.jpg)
* Mysql主从一致：   
从库复制主库的binlog日志，执行日志命令来复制（两个线程）   
* Mysql回滚   
使用begin开始一个事务，在commit之前可以回滚rollback   
* 连接池：
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个   
一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。   
数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)   
1\程序初始化时创建连接池  
2\使用时向连接池申请可用连接   
3\使用完毕，将连接返还给连接池   
4\程序退出时，断开连接，并释放资源 
* Sql搜索可以考虑的数据结构 
哈希表：搜索快但是不适合范围查找   
二叉树：容易不平衡   
AVL：旋转耗时且IO消耗较大，如果深的话   
B树：有序数组+平衡多叉树；    
每个子节点可以存放多个值，树深度降低，适合查找   
B+树：有序数组链表+平衡多叉树   
每个子节点不存放值，只存放索引（地址），在叶子节点存放所有的数据，且用链表链接所有叶子节点（更适合范围查找，减少磁盘IO次数），每次查询需要的次数是一样的 
* 存储过程：  
预先通过编译和存储在数据库的一段sql命令集合   
* redis:  
非关系型数据库，是结构型数据存储   
* 内存管理机制上：
Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU（最少使用） 算法删除数据   
