# 计算机上电到启动的过程发生了什么  （操作系统和硬件）
```
接通电源前，系统CPU 处于实模式，寻址空间为16位，cs（段寄存器）和ip（偏移寄存器）都指向固化在rom中的BIOS程序
接通电源，系统指向BIOS程序，进行硬件的检测和初始化，然后将磁盘0磁道0扇区的代码读入内存（OS的代码），设置cs和ip指向os的bootsect.s代码,控制权交os
bootsect.s引导操作系统，导入setup.s代码到指定位置，setup设置内存等一系列操作，将操作系统代码移动到0地址处，并进入保护模式（32位寻址）
执行system模块的代码，初始化os，操作系统开始执行main函数
--setup.s时候读取的内存参数在这时候初始化时用于设置mmap数组(4k 一页)，指示哪些内存已使用，哪些内存未使用
```

# 操作系统的接口————系统调用  （应用程序和操作系统）
```
操作系统分为用户态和内核态，用户态代码不能访问内核态代码，这是由硬件设定好的：执行代码是会检查DPL（目标特权级） CPL（目前特权级），满足CPL<=DPL才能执行
（用户态可以直接访问内核态是不安全的）
只能通过中断来从用户态进入内核态（INT 0x80），由系统调用实现
用户态代码-->调用system_call函数（比如wirte（））-->system_call设置中断置0x80-->触发软中断，进入内核态-->根据调用号去找对应的中断处理函数，执行对应操作-->返回用户态

```

# CPU管理 1
```
CPU功能：取值执行，从内存中一条条取代码，执行代码。
进程的概念：运行着的程序就是进程
CPU是管理进程的设备，管理CPU实际上就是管理进程，但是IO指令速度远远小于计算指令，单进程执行的化CPU效率很低
因此有了并发的概念：并发--让一个CPU交替执行多个进程，不在等待IO上浪费时间；CPU管理并发的多个进程是CPU管理的关键

进程的切换执行依赖于PCB（process control block），每个进程都有一个PCB表，存放着上下文信息，用于保护现场。进程切换时将cpu运行信息压入PCB，将要切换的进程PCB换到CPU中，完成进程切换
进程的状态：运行态 就绪态 等待/阻塞态
CPU维持三个队列 运行队列 就绪队列 等待队列，队列的头尾指针各自指向对应进程的PCB，用于进程的切换
队列的维持方式取决于调度方式--队列操作+调度+切换！

进程同步：进程之间可能共享一些资源，进程切换可能导致资源更新出错，需要进行同步，常见方法：加锁
linux系统进入main函数后，调用fork创建第一个进程（1号进程），启动shell，后续的所有其他进程都由这个1号进程产生。
```

# CPU管理2
```
进程=资源+指令执行序列
进程的切换需要切换资源，消耗大，因而引入了线程的概念，线程共享进程的资源，切换线程只需要切换指令，消耗小。
线程拥有自己的栈空间，TCB线程控制块，用于线程切换
用户线程：
	只在用户空间，不进入核空间；每个线程都有一个自己的用户栈，TCB。通过Yield函数切换到不同的线程执行；缺点：内核阻塞了的话会切换到其他进程，内核并不知道有多线程
内核线程：
	每个线程有一套用户栈核内核栈
	线程切换的过程：线程运行，陷入到内核栈，保存用户栈的信息，更新TCB，切换到其他线程，出战对应用户栈的信息，跳转到用户态执行另一个线程
## fork创建子进程：
	用户态调用fork系统调用，通过INT0X80陷入内核态，在内核态重新申请了一页内存，子进程拥有了自己的内核栈，但内核栈指向的用户栈仍然时从父进程复制过来的
	即 子进程和父进程拥有同一个用户栈，各自拥有自己的内核栈(后面通过exec修改)
```

# CPU管理3 
```	
	cpu调度，CPU调度要综合折中响应时间和周转时间，
	常见的CPU调度方法：FIFO FCFS（先来先服务） SJF(短作业优先) 时间片轮转ROUND Robin 优先级调度
	单纯的优先级调度会导致低优先级的进程饿死，因此常用动态更新优先级+时间片轮转进行调度，保证了响应时间的同时，优先IO密集型进程
```

# 进程同步
```
	通过信号量实现
	信号量表示还有多少资源，通过PV操作进行加减
	每次进行一次P操作将信号量减一，如果信号量<0，表示没有资源，则进入sleep
	每次进行一次V操作将信号量加一，如果信号量<=0,表示还有进程等待中，则wakeup一个进程。
	通过信号量保证了进程之间的同步
```