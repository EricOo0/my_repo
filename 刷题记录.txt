leetcode刷题记录：
	栈stack（迭代、递归、单调栈、树）
	2020/10/2：
		1047.删除字符串中的所有相邻重复项  简单————简单的压栈出栈 ————
			 可优化：a+=1的效率要高于a=a+1 ; reverse() 反转字符串或数组函数
		1598. 文件夹操作日志搜集器 简单————文件路径也是先入后出，利用栈存放当前文件夹
		！！496. 下一个更大元素 I 简单题————一
									————单调栈解决，单调栈一般用于 下一个更大的。。。的问题，有函数模板，一般从后往前遍历（因为是找下一个大的/小的）
									
									for(int i = len-1; i>=0;i--){
										while(!tem.empty() && nums2[i] > tem.top()){
											tem.pop();
										}
										if(tem.empty()){ ret[nums2[i]]=-1;}
										else {ret[nums2[i]] = tem.top();}
										tem.push(nums2[i]);
									}
									也可从前往后遍历，单调减/增
	2020/10/6：
		682. 棒球比赛 简单
			常用函数：std::stoi（string str） 字符串转int
		173. 二叉搜索树迭代器 中等
			1.利用二叉搜索树中序遍历是有序的特性，将数据存放在双向队列中，得到一个升序的队列，然后依次出队列
			2.利用栈先入后出的思想，每次压入左子树，压到头时为最小值
			  每次出栈，压入栈定元素的右子树的所有左子树，使栈顶为次最小
	2020/10/7：
		94. 二叉树的中序遍历 -中等
			递归很简单 
			递归和迭代区别：递归是自己不停调用自己 迭代是重复调用其他函数（循环）
			迭代用栈实现
			    while(true){
					while(NULL != tem){
						inorder.push(tem);
						tem = tem->left;
					}
					TreeNode* node = inorder.top();
					inorder.pop();
					res.push_back(node->val);
					tem = node->right;
					if(tem != NULL ){continue;}
					if(inorder.empty()){return res;}	
				}	
	2020/10/8：
		503. 下一个更大元素 II  中等 
			思路于496类似，维护一个单调栈，但因为是循环数组，所以要遍历两遍数组
	堆heap（大顶堆和小顶堆在C++中的实现是优先队列priority_queue<>）：
		小顶堆：priority_queue<int, vector<int>, greater<int> > q
		常用来解决最大k个，最小k个等问题
		1046. 最后一块石头的重量 简单 利用大顶堆解决
		面试题 17.14. 最小K个数 中等 利用小顶堆解决
	2020/10/11
	哈希表：hash_map<a,b>不在stl里; map<a,b>;unordered_map<a,b>(一般用这个)
		1512. 好数对的数目 简单——1、暴力法遍历n^2  2、哈希表 空间换时间
		1365. 有多少小于当前数字的数字 简单
	2020/10/14
		535. TinyURL 的加密与解密   中等 ————简单遍历哈希表即可 unordered_map (first,seceond)
		面试题 16.02. 单词频率 中等 ————unordered_map 计数
		957. N 天后的牢房  中等——————vector应用：拷贝：vector.swap(vb)///vector.assign(vb.begin(),vb.end())
								1、暴力法：用两个vector 旧数组遍历新数组存储 ——超出时间限制
								2、8间牢房，会出现重复，用哈希表存储记录
	2020/10/25
		字符串
			434. 字符串中的单词数————找空格即可
			537. 复数乘法！！ 
				  类型转化：to_string() 数值转化为string型  ；sprintf（）；
							stoi();字符串转数；
							提取子串substr();
					熟悉字符类型转化的函数
			面试题 17.11. 单词距离 
					1、遍历vector，每次找到对应的单词，计算和另一个单词的距离，保存最小值。最小距离必定是这个单词b前一个a或者后一个a
	2020./10/28 
			539. 最小时间差:字符串转数值 可用streamstring或者substr+stoi
							排序后算相邻数差值 O（N），一次遍历即可，隔着的元素差值比大于中间的
							当大于12小时时，时间差是1440-差值；
	2020/10/31
			49. 字母异位词分组!!!!!:利用哈希表，字符串的字符和+字符积为key、
			1410. HTML 实体解析器：string.substr(begin,len);
			1138. 字母板上的路径 
               2020/11/1 
 			1419. 数青蛙——————模拟， 正常情况c>=r&&o>=a&&a>=k
								vecotor的find（）寻找对应元素的迭代器，distance（）计算迭代器对应的下标
	2020/11/15
		402. 移掉K位数字  ————单调栈（遇上最大（小）k位，移除k位的题 可以考虑单调栈和堆来解决）这题的第一思路反应是要顺序遍历字符串，所以可以考虑单调栈相当于从前往后找出最小的排列
							单调栈不一定要用栈来做，可以用vector做，vec.back（)来增加和删除元素；vector来最后处理数字和字符方便一点
	
	2020/1121
		开始刷程序员面试经典
			面试题 02.03. 删除中间节点
				基础的操作链表，自己变成下一个，删除下一个节点，直接指向下下个；
				！！拓展：链表判断有环：快慢指针，相遇即是有环
					   求环的长度：从第一次相遇开始（不一定是纯环，所以要从第一次相遇开始），再次相遇快指针刚好比慢指针多走一圈（2：1是，一次多走一个单位，第二次追上干好多走一圈）
					   入环的点（柄的长度）：快慢指针：第一次相遇时  慢：S=len + x  快：2s=len +n*C+x （C是环的长度，求len ）；len+x =n*C ；所以相遇时把快指针放回起点并按满指针的速度走，走到入口时刚好相遇（len+x为周长整数倍）
			面试题 04.02. 最小高度树		 
					递归建树；排序的数组，所以取中值为根节点，递归左右得到子树
			面试题 02.02. 返回倒数第 k 个节点
					双指针
					也可以用栈
	2020/11/22 
			面试题 01.01. 判定字符是否唯一
					用set或者map
			面试题 03.04  化栈为队  两个栈做一个队
			面试题 05.07. 配对交换  利用两个vector 交换奇偶元素 在通过位运算组合成整数
	2020、11、25
			面试题 01.02. 判定是否互为字符重排
				1用一个map收集字母 另一个字符串出现了就-- 最后判断map是否空
				2排序再比较
	2020/11/28
			！面试题 08.06. 汉诺塔问题: !!!!递归思路
			面试题 17.04. 消失的数字：1 用map记录 2数学方法 0到n的和可以用公式算，遍历一遍数组求和，相差为缺失的值、
			!（回头再做一遍）面试题 17.12. BiNode ：也是递归 ，双链表转换单链表（！！！搜索二叉树的中序遍历时升序的！！！特性）
	2020/12/5		
			面试题 03.02. 栈的最小值  
			面试题 03.06. 动物收容所   题目有点拗口，特点：先入先出 使用两个queue解决 编号小的代表进入早，时间久 先出去
			面试题 16.17. 连续数列 简单的动态规划
			面试题 01.03. URL化  string遍历 ；可以用双指针原址操作从后往前！
			面试题 17.01. 不用加号的加法  位运算  a^b （1+0，0+1）没有进位部分的和   a&b<<1（1+1=10） 计算进位  进位不为0的话继续加进位
	2020/12/6
			面试题 17.10. 主要元素  用map记录
			面试题 04.04. 检查平衡性 递归 判断左右子树高度差不超过1并且都是平衡树就为平衡
			面试题 10.05. 稀疏数组搜索 一遍遍历；或者二分查找提高效率 
	2020/12/7
			面试题 08.10. 颜色填充  递归 记得考虑无限递归情况；还有一道小岛环湖的也是类似思路
	2020/12/8
			面试题 01.09. 字符串轮转  不要想的太复杂， C++有stl标准库可以用，substr提取子串！！！ 找到轮转点，比较后边的子串是否相等，再比较前面的子串
									简便方法：s1 + s1 形成的字符串中一定可以找到子串s2 使用s3.find(s2)！=string::npos！！
									
			面试题 01.04. 回文排列  ：判断是否是回文串可以用双指针，判断是否回文串的排列，可以用map，遍历完看奇数的元素是否多余一个 ，map的遍历for(auto &elem:map) elem.second!注意没有括号。
			面试题 10.01. 合并排序的数组  1、直接用sort排序后返回
											2、双指针 从后往前比较，大的往后挪
	2020/12/10
			面试题 03.01. 三合一 数值 和指针，转换成数值下标操作
			面试题 17.16. 按摩师  排列组合最优值用动态规划
			面试题 05.06. 整数转换  位运算 ————注意负数； 
	2020/12/11
			面试题 08.01. 三步问题  递归！深度太深超出时间限制！   利用动态规划的思路
	2020/12/12
			面试题 01.06. 字符串压缩  如果是排好序的，可以直接用set或map；会重复出现，遍历一遍，string记得要初始化，不然会造成一些奇怪的错误
			
			面试题 05.01. 插入  覆盖：实际上就是加上，但是要先把N的对应位置零（置零实际上是减去）
	2020/12/13
			面试题 16.15. 珠玑妙算   伪拆中包括了猜中  ；用一个map村粗颜色出现的频数	
			面试题 16.05. 阶乘尾数    数学题 ！n阶里有几个 5的倍数；   n/5=x；有x个5的倍数； x/5=y;有y个25的倍数，y/5=z 有z个125的倍数；利用这条性质循环直到n<5;
			面试题 05.03. 翻转数位    数位统计，需要移位;记录0前和0后的1的位数；考虑负数和全1的情况，需要看res的大小
	2020/12/14
			面试题 16.01. 交换数字  :一个数异或自己两次，值不变；自己异或自己为0；  如果使用a=a+b,b=a-b;a=a-b;可能会造成溢出
			！！！面试题 08.09. 括号   回溯算法 有停止条件  ;类似递归，一直调用backtrace方法，有结束条件！
			!!全排列问题 考虑用回溯算法
			！！！面试题 08.07. 无重复字符串的排列组合  回溯，遍历一遍S字符串，没用过的就压入新字符串，继续调用回溯；(能进就进，不能进或结束就返回，继续下一个字符再调用)
							公式
								  void backtrack(string& S, vector<string>& res, string& path, vector<bool>& used) {
												if ( S.size() == path.size() ) {
													res.emplace_back(path);
													return;
												}
												for ( int i = 0; i < S.size(); ++i ) {
													if ( !used[i] ) {
														path.push_back(S[i]);
														used[i] = true;
														backtrack(S, res, path, used);
														path.pop_back();
														used[i] = false;
													}
												}

			！！！面试题 08.04. 幂集   回溯算法可以画树找思路，实质上应该是dfs加剪枝优化


	2020/12/21
			面试题 04.03. 特定深度节点链表   广度优先搜索，利用deque和vector两个循环，一层一层搜索
	2020、12、22
			面试题 01.07. 旋转矩阵  数学方法 矩阵转置+行首尾呼唤；利用异或减少空间消耗
			string判断是否为子串函数：strstr(a,b)在a中查找b，若存在返回位置指针，不存在返回NULL
										s1.find(s2) 存在返回位置不存在返回npos
			面试题 04.10. 检查子树 ——前序遍历转化为两个字符串，然后比较是否为子串	；需要给空节点占位；
									 也可以用递归，先在t1中找到t2当前节点的值在比较左右子树
	2020/12/29
		面试题 16.20. T9键盘  使用一个vector 做匹配；
		面试题 08.08. 有重复字符串的排列组合 ；用回溯算法遍历所有可能，有重复的用find函数查找去掉（剪枝还有更好的思路，一个if判断）；用一个used数组存储用过的字符；
	2021/1/1
		面试题 04.08. First Common Ancestor LCCI
			最近公共祖先，深度优先搜索思路，找到符合的节点后将该节点返回，左右子树返回值都不为空，则这个节点为最近公告祖先
		面试题 16.10. Living People LCCI
			同时存活人数最多的年份。for循环判断，记录每一年存货的最多人数，有人死亡就去掉一个；
			或者使用存活的前缀和减去死亡的前缀和
	2021/1/11
		面试题 08.05	递归乘法  ；乘法转加法
		面试题 10.02. 变位词组  ！！ 变位词排序之后是一样的，利用这一点转换成哈希表解决来分类。
	2021/1/17
		面试题 10.11. 峰与谷 遍历数组，依次与下个元素比较，奇数为谷 要比下一个元素小，偶数为锋 要比下一个元素大
		面试题 02.04. 分割链表  ；在头节点前增加一个节点，遍历链表，遇到比x小的就插入到头节点前
		面试题 05.02. 二进制数转字符串  ;二进制小数位一直除2，
	2021/1/19
		面试题 01.08. 零矩阵;遍历一遍存储为0的行和列，清空
	2021/1/23
		!!面试题 16.19. 水域大小:深度优先搜索,找到水坑之后遍历周围，有就继续遍历，另写一个dfs函数遍历，要有一个visited判断是否访问过
	2021/1/30
		/**
		 * Definition for singly-linked list.
		 * struct ListNode {
		 *     int val;
		 *     ListNode *next;
		 *     ListNode(int x) : val(x), next(NULL) {}
		 * };
		 */	
		 记住链表的构造方法
	2021、2、1：
		888. 公平的糖果棒交换；推导数学公式，(sum_a-sum_b)/2 +y=x;
滑动窗口篇：
	2021/2/5
		1208. 尽可能使字符串相等  ___滑动窗口求解
	2021、2、6
		1423. 可获得的最大点数;只能从数组头尾取值，转换思路，找数组中连续的n-k个最小和，剩下的则是最大和
	2021/2/8
		978. 最长湍流子数组; 滑动窗口，当比较符号是连续翻转时扩大窗口，反之移动窗口
	2021、2、10
		567. 字符串的排列  滑动窗口：创建两个长度26的vector，存储两个字符串字符frequency，在S2上滑动，记录数组是否和s1一样；
	2021、2、21
		1438. 绝对差不超过限制的最长连续子数组   ！!!利用multiset 大排序特性
	2021、2、23
		1052. 爱生气的书店老板  先统计正常情况下的满意度，再利用滑动窗口计算每个窗口增加的额外满意度！！